const ethers = require('ethers');
const { Buffer } = require('buffer');
const { keccak256 } = require('ethereumjs-util');
const elliptic = require('elliptic');
const crypto = require('crypto');
const fs = require('fs');

const ec = new elliptic.ec('secp256k1');

class StealthAddress {
  constructor() {
    const ecs = new elliptic.ec('secp256k1');
  }


  // Generate a new ephemeral key pair


  // Generate a stealth address
  generateStealthAddress(recipientPublicKey) {

    // return { privateKey, publicKey };
    const { privateKey: ephPrivateKey, publicKey: ephPublicKey } = this.generateEphemeralKeyPair();

    const recipientPublicKeyBytes = Buffer.from(recipientPublicKey, 'hex');

    const recipientPublicKeyPoint = ec.keyFromPublic(recipientPublicKeyBytes).getPublic();
    const ephemeralPublicKeyPoint = ec.keyFromPublic(ephPublicKey).getPublic();

    const sharedSecretPoint = recipientPublicKeyPoint.mul(ephPrivateKey);

    const pointBuffer = Buffer.from(sharedSecretPoint.encode('array'));
    const hashedSecret = Buffer.from(keccak256(pointBuffer))
    const bnHashedSecret = ec.keyFromPrivate(hashedSecret).getPrivate();

    // Multiply the hashed shared secret with the generator point of the elliptic curve Kh=khÃ—G .

    // const hashedSecret = ethers.keccak256(sharedSecretPoint);
    console.log("sfsdf")
    // recipientPublicKeyPoint, ephPrivateKey

    // const sharedSecret = this.curve.multiply(recipientPublicKey, ephPrivateKey);
    // const hashedSecret = ethers.utils.keccak256(sharedSecret);
    const hue = ec.g

    const Kh = ec.g.mul(bnHashedSecret);
    const stealthPublicKey = Kh.add(recipientPublicKeyPoint);

    const stealthAddressHexPublicKey = stealthPublicKey.encode("hex", true)
    const stealthAddress = ethers.computeAddress('0x' + stealthAddressHexPublicKey);
    // stealthPublicKey.encode("hex", true)

    return {
      ephemeralPublicKey: ephPublicKey.encode("hex", true),
      stealthPublicKey: stealthPublicKey.encode("hex", true),
      stealthAddress
    };
  }

//  async parseAndCheckStealthAddresses(privateKey, ephemeralPublicKeys) {
//     const ownedAddresses = [];

//     // const { privateKey: ephPrivateKey, publicKey: ephPublicKey } = this.generateEphemeralKeyPair();

//     // const recipientPublicKeyPoint = ec.keyFromPublic(recipientPublicKey, 'hex').getPublic();
//     // const ephemeralPublicKeyPoint = ec.keyFromPublic(ephPublicKey).getPublic();

//     // const sharedSecretPoint = recipientPublicKeyPoint.mul(ephPrivateKey);

//     // const pointBuffer = Buffer.from(sharedSecretPoint.encode('array'));
//     // const hashedSecret = Buffer.from(keccak256(pointBuffer))
//     // const bnHashedSecret = ec.keyFromPrivate(hashedSecret).getPrivate();

//     for (const ephemeralPublicKey of ephemeralPublicKeys) {

//     const ephemeralPublicKeyPoint = ec.keyFromPublic(ephemeralPublicKey, 'hex').getPublic();
//     const sharedSecret = ephemeralPublicKeyPoint.mul(privateKey);
//     const hashedSecret = keccak256(sharedSecret);
//     const recipientPrivateKeyBn = recipientPrivateKey.getPrivate();
//     const hashedSecretBn = ec.keyFromPrivate(hashedSecret).getPrivate();
//     const stealthPrivateKey = recipientPrivateKeyBn.add(hashedSecretBn);
//     // hashedSecret.add
//     // const stealthPrivateKey = ethers.hexZeroPad(
//     // ethers.BigNumber.from(privateKey).add(hashedSecret).toHexString(),
//     // 32
//     // );
//     const stealthPublicKey = ec.keyFromPublic(ephemeralPublicKey, 'hex').getPublic();
//     // const stealthPublicKey = this.curve.getPublicKey(stealthPrivateKey);
//     // stealthPublicKey.encode("hex", true)
//     const stealthAddress = ethers.utils.computeAddress("0x" + stealthPublicKey.encode("hex", true));

//     // Check if this address has received any transactions or has a balance
//     const hasActivity = await this.checkAddressActivity(stealthAddress);

//     if (hasActivity) {
//     ownedAddresses.push({
//         stealthPrivateKey,
//         stealthPublicKey,
//         stealthAddress
//     });
//     }
// }

//     return ownedAddresses;
//   }




    generateKeyPair() {
        const key = ec.genKeyPair();
        return {
            privateKey: key.getPrivate(),
            publicKey: key.getPublic(),
        };
}

   // Parse and check stealth addresses
   async parseAndCheckStealthAddresses(recipientPrivateKey, ephemeralPublicKeys) {
    const ownedAddresses = [];

    for (const ephemeralPublicKey of ephemeralPublicKeys) {
    const ephemeralPublicKeyPoint = ec.keyFromPublic(ephemeralPublicKey, 'hex').getPublic();
    const sharedSecret = ephemeralPublicKeyPoint.mul(recipientPrivateKey);
    //   const sharedSecret = this.curve.multiply(ephemeralPublicKey, privateKey);
    const hashedSecret = Buffer.from(keccak256(Buffer.from(sharedSecret.encode('array'))));
    const recipientPrivateKeyBn = ec.keyFromPrivate(recipientPrivateKey).getPrivate();
    const hashedSecretBn = ec.keyFromPrivate(hashedSecret).getPrivate();

    // const hashedSecret = keccak256(sharedSecret);
    // const recipientPrivateKeyBn = recipientPrivateKey.getPrivate();
    // const hashedSecretBn = ec.keyFromPrivate(hashedSecret).getPrivate();
    const stealthPrivateKey = recipientPrivateKeyBn.add(hashedSecretBn);

    // const hashedSecret = keccak256(sharedSecret);
    // const stealthPrivateKey = ethers.hexZeroPad(
    // ethers.BigNumber.from(privateKey).add(hashedSecret).toHexString(),
    // 32
    // );
    const stealthPublicKey = ec.keyFromPrivate(stealthPrivateKey).getPublic();
    // const stealthPublicKey = ec.keyFromPrivate(recipientPrivateKey).getPublic();
    // const stealthPublicKey = this.curve.getPublicKey(stealthPrivateKey);
    const stealthAddress = ethers.computeAddress('0x' + stealthPublicKey.encode('hex', true));

    console.log("stealth AD from PARSING =======>: ", stealthAddress)

    // Check if this address has received any transactions or has a balance
    // WIP PELASE FIX LASTER, SHOULD CHECK BLOCKCHAIN FOR TRANSACTION RELATED TO THE STEALTH ADDRESS
    // const hasActivity = await this.checkAddressActivity(stealthAddress);

    // ownerAndstealthAddress
    
    const stealthAddresses = fs.readFileSync('stealthAddresses.txt', 'utf-8').split('\n').filter(Boolean);

    // const hasActivity = true;

    stealthAddresses.forEach((loopedStealthAddress) => {
        
        if (loopedStealthAddress == stealthAddress) {
            ownedAddresses.push({
                stealthPrivateKey,
                stealthPublicKey,
                stealthAddress
            });
            }
    })
}
    return ownedAddresses;
  }

  // Parse and check dual-key stealth addresses
  async parseAndCheckDualKeyStealthAddresses(scanningPrivateKey, spendingPrivateKey, ephemeralPublicKeys) {
    const ownedAddresses = [];

    const stealthAddresses = fs.readFileSync('stealthAddresses.txt', 'utf-8').split('\n').filter(Boolean);

    for (const ephemeralPublicKey of ephemeralPublicKeys) {

    const ephemeralPublicKeyBn = ec.keyFromPublic(ephemeralPublicKey, 'hex').getPublic();
    const sharedSecret = ephemeralPublicKeyBn.mul(scanningPrivateKey);
    const hashedSecret = Buffer.from(keccak256(Buffer.from(sharedSecret.encode('array'))));
    const hashedSecretBn = ec.keyFromPrivate(hashedSecret).getPrivate();

    const spendingPrivateKeyBn = ec.keyFromPrivate(spendingPrivateKey).getPrivate();
    const stealthPrivateKey = spendingPrivateKeyBn.add(hashedSecretBn);

      

    //   const stealthPrivateKey = ethers.utils.hexZeroPad(
    //     ethers.BigNumber.from(spendingPrivateKey).add(hashedSecret).toHexString(),
    //     32
    //   );


    const stealthPublicKey = ec.keyFromPrivate(stealthPrivateKey).getPublic();
    //   const stealthPublicKey = this.curve.getPublicKey(stealthPrivateKey);
    //   const stealthAddress = ethers.utils.computeAddress(stealthPublicKey);
    const stealthAddress = ethers.computeAddress('0x' + stealthPublicKey.encode('hex', true));


      // Check if this address has received any transactions or has a balance
    stealthAddresses.forEach((loopedStealthAddress) => {
    // console.log("")
    if (loopedStealthAddress == stealthAddress) {
        ownedAddresses.push({
            stealthPrivateKey,
            stealthPublicKey,
            stealthAddress
        });
        }
})
}
    return ownedAddresses;
  }

  // Helper method to check if an address has any activity
  async checkAddressActivity(address) {
    // This is a placeholder. In a real implementation, you would:
    // 1. Check the address balance
    // 2. Check for any incoming transactions
    // You'd typically use a blockchain explorer API or your own node for this
    
    const provider = new ethers.providers.JsonRpcProvider('YOUR_RPC_URL');
    const balance = await provider.getBalance(address);
    const transactionCount = await provider.getTransactionCount(address);

    return !balance.isZero() || transactionCount > 0;
  }

  generateEphemeralKeyPair() {
    const key = ec.genKeyPair()
    // const key = this.ec.genKeyPair();
    const privateKey =  key.getPrivate()
    const publicKey = key.getPublic()
    return { privateKey, publicKey };
}

    generateAccount() {
        const key = ec.genKeyPair()
        // const key = this.ec.genKeyPair();
        const privateKey =  key.getPrivate().toString()
        const publicKey = key.getPublic.encode('hex')
        return { privateKey, publicKey };
}

    publicKeyToAddress(publicKey) {
    // Remove the '04' prefix that indicates uncompressed public key
    const publicKeyBuffer = Buffer.from(publicKey.slice(2), 'hex');
    // Compute the Keccak-256 hash of the public key
    const hash = keccak256('keccak256').update(publicKeyBuffer).digest();
    // Take the last 20 bytes as the Ethereum address
    const address = `0x${hash.slice(-20).toString('hex')}`;
    return address;
}

    /**
     * Generates a stealth meta-address
     * @param {string} recipientPublicKey - The recipient's public key in hex format
     * @param {string} ephemeralPrivateKey - The ephemeral private key in hex format
     * @returns {Object} - The generated stealth address, ephemeral public key, and shared secret
     */
    generateStealthMetaAddress(viewPublicKey, spendingPublicKey) {
        // const stealthMetaAddress = 'sa:eth' + viewPublicKey + spendingPublicKey;
        const stealthMetaAddress = viewPublicKey + spendingPublicKey;
        // return '0x' + stealthMetaAddress;
        return stealthMetaAddress;
    }

}



// Usage example
async function scanForOwnedStealthAddresses(privateKey, allEphemeralPublicKeys) {
  const stealth = new StealthAddress();
  const ownedAddresses = await stealth.parseAndCheckStealthAddresses(privateKey, allEphemeralPublicKeys);
  
  console.log('Owned Stealth Addresses: \n');
  ownedAddresses.forEach(addr => console.log(addr.stealthAddress));
}


// function generateEphemeralKeyPair() {
//     const privateKey = ethers.randomBytes(32);
//     const publicKey = this.curve.getPublicKey(privateKey);
//     return { privateKey, publicKey };
//   }

async function startStealth() {

    const stealthGen = new StealthAddress();

    // let recipientPrivateKey = ''

    

    // USE THIS TO GEN RANDOM KEYS
    // let {privateKey: recipientPrivateKey, publicKey: recipientPublicKey} = stealthGen.generateEphemeralKeyPair(); 

    // return {
    //     ephemeralPublicKey: ephPublicKey.encode("hex", true),
    //     stealthPublicKey: stealthPublicKey.encode("hex", true),
    //     stealthAddress
    //   };

    // recipientPrivateKey = ec.keyFromPrivate(recipientPrivateKey).getPrivate();

//     owners private key ----> 0x1405424859793730169826736393316438933964644334549480490790968894454166706659owners public Key----> 0x04bf71f0df8a3e3a9322fa6fc0d9bfb9f2464f9dc9d9665544b476ad93a57ff1b1248fff1d149d1e0154164d370ed8e2577f22b17cfb2a68ecdb6acefb06e667bc   Stealth address ----> 0xf7f76EF3C40a0765fB14263a46240a9DDCf6C288
// owners private key ----> 0x39663234896045775658019693523711066115734998980166797591628881117242979917492owners public Key----> 0x041b3d8f455401b700534ecc92608ebf51ba8ed7618ceba107d531bcbd91c1e8da2c1052eceeaf16966e2b3f6c22dbf940654abe51fc76d2b5ca659466d9482c69   Stealth address ----> 0xc7DeDcE55858fdB50c225ecc712819aaF33AC062

// Account #0: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 (10000 ETH)
// Private Key: 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

// Account #1: 0x70997970C51812dc3A010C7d01b50e0d17dc79C8 (10000 ETH)
// Private Key: 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d

// let recipientPrivateKey = '59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d'
// let recipientPublicKey = '70997970C51812dc3A010C7d01b50e0d17dc79C8'

let recipientPrivateKey = 'ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80'
let recipientPublicKey = 'f39Fd6e51aad88F6F4ce6aB8827279cffFb92266'


// Create key pair from recipient's private key
const recipientKeyPair = ec.keyFromPrivate(recipientPrivateKey);

// Get recipient's public key as an elliptic curve point
const recipientPublicKeyPoint = recipientKeyPair.getPublic().encode('hex', true);


// generateKeyPair() {
//     const key = ec.genKeyPair();
//     return {
//         privateKey: key.getPrivate(),
//         publicKey: key.getPublic(),
//     };
// }


// crypto.generateKeyPair();
const {privateKey: scanningPrivateKey, publicKey: scanningPublicKey} = await stealthGen.generateKeyPair();
const {privateKey: spendingPrivateKey, publicKey: spendingPublicKey} = await stealthGen.generateKeyPair();


// return '0x' + stealthMetaAddress;
const stealthMetaAddress = await stealthGen.generateStealthMetaAddress(); 

// let recipientPrivateKey = '3186038726056885935121135688289776529166375157817136540309451650122677861739'
// let recipientPublicKey = '04219eedccfc5459099614f91d77a4c32dcd85d0b37ad6e163ffbbcbbb82219bd858e076a7f7665154284162c00f0049c7c994bf4fe51e62d15d3ba7253b37c02e'

// let recipientPrivateKey2 = '0x5918831687843387128759341021956543796225407287840748898820267765050792402363'
// let recipientPublicKey2 = '0x04d4aa5c193e2ee546ccd2fb9037cd01a6b863fb14171e6bfd930a2d49dff65441ea3f30b9d644d0b71b5c46a12fa87736d4683150e2735cfc37e4df82c8bd6771'

const {ephemeralPublicKey, stealthPublicKey, stealthAddress} = await stealthGen.generateStealthAddress(recipientPublicKeyPoint);
    
    // const address = publicKeyToAddress(publicKey);
    // stealthAddress

    // owners private key ----> 0x3186038726056885935121135688289776529166375157817136540309451650122677861739owners public Key----> 0x04219eedccfc5459099614f91d77a4c32dcd85d0b37ad6e163ffbbcbbb82219bd858e076a7f7665154284162c00f0049c7c994bf4fe51e62d15d3ba7253b37c02e   Stealth address ----> 0x8c5f35d4b3cE352c086C20B382b9a4F20B40f753
    // owners private key ----> 0x5918831687843387128759341021956543796225407287840748898820267765050792402363owners public Key----> 0x04d4aa5c193e2ee546ccd2fb9037cd01a6b863fb14171e6bfd930a2d49dff65441ea3f30b9d644d0b71b5c46a12fa87736d4683150e2735cfc37e4df82c8bd6771   Stealth address ----> 0x23Ceb5b9Ad8C5d1F2Aea8eC5008e7fD26A8072A3
    


    

    fs.writeFileSync('ephemeralPublicKeys.txt', ephemeralPublicKey + '\n', { flag: 'a' });
    fs.writeFileSync('stealthAddresses.txt', stealthAddress + '\n', { flag: 'a' });
    fs.writeFileSync('ownerAndstealthAddress.txt', 'owners private key ----> ' + '0x' + recipientPrivateKey + 
        'owners public Key----> ' + '0x' + recipientPublicKey +
        // 'owners public Key----> ' + '0x' + recipientPublicKey.encode('hex') +
        '   Stealth address ----> ' + stealthAddress + '\n', { flag: 'a' });


    console.log('Eph Public key ============> \n', ephemeralPublicKey,'Stealth public key ============> \n',
         stealthPublicKey, 'Stealth adress ============> \n',stealthAddress)

    // ITS A MOCK --- PLS REMEMBER TO FIX IT LATER, THE EPHEMERAL KEYS SHOULD COME FROM SCANNING THROUGH THE BLOCKCHAIN NETWORK


    // return {
    //   ephemeralPublicKey: ephemeral.publicKey,
    //   stealthPublicKey,
    //   stealthAddress
    // };

    // const recipientPrivateKeyHex = '0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef';
    // const recipientPublicKeyHex = ec.keyFromPrivate(Buffer.from(recipientPrivateKeyHex.slice(2), 'hex')).getPublic('hex'); // Convert private key to public key hex


    const allEphemeralPublicKeysFromNetwork = fs.readFileSync('ephemeralPublicKeys.txt', 'utf-8').split('\n').filter(Boolean);

    stealthGen.parseAndCheckDualKeyStealthAddresses(scanningPrivateKey, spendingPrivateKey, allEphemeralPublicKeysFromNetwork) 
    // You would call this function periodically or when new ephemeral public keys are published
    // scanForOwnedStealthAddresses(recipientPrivateKey, allEphemeralPublicKeysFromNetwork);

}

startStealth();
